import type { Metadata } from 'next';
import { Fjord_One } from 'next/font/google';
import './globals.css';
import ThemeProvider from '@/components/ThemeProvider';

const fjordOne = Fjord_One({
  variable: '--font-fjord-one',
  weight: '400',
  subsets: ['latin'],
  display: 'swap',
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

// Helper: convert hex to rgb object
function hexToRgbObj(hex: string) {
  const normalized = hex?.replace(/^#/, '') || '';
  if (normalized.length !== 6) return null;
  const r = parseInt(normalized.substring(0, 2), 16);
  const g = parseInt(normalized.substring(2, 4), 16);
  const b = parseInt(normalized.substring(4, 6), 16);
  return { r, g, b };
}

function shadeRgb(rgb: { r: number; g: number; b: number }, factor: number, darken = false) {
  if (!rgb) return `${rgb}`;
  if (darken) {
    return `${Math.round(rgb.r * factor)}, ${Math.round(rgb.g * factor)}, ${Math.round(rgb.b * factor)}`;
  }
  return `${Math.round(rgb.r + (255 - rgb.r) * (1 - factor))}, ${Math.round(
    rgb.g + (255 - rgb.g) * (1 - factor),
  )}, ${Math.round(rgb.b + (255 - rgb.b) * (1 - factor))}`;
}

async function fetchOrganizationSettings() {
  try {
    const backend = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8080';
    const res = await fetch(`${backend}/api/public/organization/settings`, { cache: 'no-store' });
    if (!res.ok) return null;
    return await res.json();
  } catch {
    // Silence: fallback handled by defaults
    return null;
  }
}

export default async function RootLayout({
                                           children,
                                         }: Readonly<{
  children: React.ReactNode;
}>) {
  // Récupérer les réglages côté serveur pour injecter les variables CSS immédiatement
  const settings = await fetchOrganizationSettings();

  // Normaliser les clés possibles renvoyées par l'API (camelCase ou snake_case, alias accent)
  const primaryFromSettings =
    settings?.primaryColor || settings?.primary_color || settings?.accentColor || settings?.accent_color;
  const secondaryFromSettings = settings?.secondaryColor || settings?.secondary_color;

  const primary = primaryFromSettings || '#3b82f6';
  const secondary = secondaryFromSettings || '#64748b';

  const pRgb = hexToRgbObj(primary) || { r: 59, g: 130, b: 246 };
  const sRgb = hexToRgbObj(secondary) || { r: 100, g: 116, b: 139 };

  // build shades for 50..900 similar to front-end logic
  // Background / text from settings (fallbacks)
  const bgFromSettings =
    settings?.background || settings?.background_color || settings?.color_background || '#ffffff';
  const textFromSettings =
    settings?.textColor || settings?.text_color || settings?.color_text || '#171717';

  // Dark-mode overrides coming from backend (optional). If backend doesn't provide dark-specific values,
  // fall back to the normal settings so the site won't become all black when the OS is in dark mode.
  const bgDarkFromSettings =
    settings?.backgroundDark || settings?.background_dark || settings?.color_background_dark || bgFromSettings;
  const textDarkFromSettings =
    settings?.textColorDark || settings?.text_color_dark || settings?.color_text_dark || textFromSettings;

  const inlineCss = `:root {
    --color-primary: ${primary};
    --color-primary-50: ${shadeRgb(pRgb, 0.95)};
    --color-primary-100: ${shadeRgb(pRgb, 0.9)};
    --color-primary-200: ${shadeRgb(pRgb, 0.8)};
    --color-primary-300: ${shadeRgb(pRgb, 0.7)};
    --color-primary-400: ${shadeRgb(pRgb, 0.6)};
    --color-primary-500: ${pRgb.r}, ${pRgb.g}, ${pRgb.b};
    --color-primary-600: ${shadeRgb(pRgb, 0.8, true)};
    --color-primary-700: ${shadeRgb(pRgb, 0.7, true)};
    --color-primary-800: ${shadeRgb(pRgb, 0.6, true)};
    --color-primary-900: ${shadeRgb(pRgb, 0.5, true)};

    --color-primary-light: color-mix(in srgb, ${primary}, white 60%);
    --color-primary-dark: color-mix(in srgb, ${primary}, black 40%);

    --color-secondary: ${secondary};
    --color-secondary-50: ${shadeRgb(sRgb, 0.95)};
    --color-secondary-100: ${shadeRgb(sRgb, 0.9)};
    --color-secondary-200: ${shadeRgb(sRgb, 0.8)};
    --color-secondary-300: ${shadeRgb(sRgb, 0.7)};
    --color-secondary-400: ${shadeRgb(sRgb, 0.6)};
    --color-secondary-500: ${sRgb.r}, ${sRgb.g}, ${sRgb.b};
    --color-secondary-600: ${shadeRgb(sRgb, 0.8, true)};
    --color-secondary-700: ${shadeRgb(sRgb, 0.7, true)};
    --color-secondary-800: ${shadeRgb(sRgb, 0.6, true)};
    --color-secondary-900: ${shadeRgb(sRgb, 0.5, true)};

    --color-secondary-light: color-mix(in srgb, ${secondary}, white 60%);
    --color-secondary-dark: color-mix(in srgb, ${secondary}, black 40%);

    /* Background & text: explicit defaults from backend (ensure SSR reflects organization settings) */
    --color-background: ${bgFromSettings};
    --color-text: ${textFromSettings};
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-primary: ${primary};
      --color-primary-50: ${shadeRgb(pRgb, 0.95)};
      --color-primary-100: ${shadeRgb(pRgb, 0.9)};
      --color-primary-200: ${shadeRgb(pRgb, 0.8)};
      --color-primary-300: ${shadeRgb(pRgb, 0.7)};
      --color-primary-400: ${shadeRgb(pRgb, 0.6)};
      --color-primary-500: ${pRgb.r}, ${pRgb.g}, ${pRgb.b};
      --color-primary-600: ${shadeRgb(pRgb, 0.8, true)};
      --color-primary-700: ${shadeRgb(pRgb, 0.7, true)};
      --color-primary-800: ${shadeRgb(pRgb, 0.6, true)};
      --color-primary-900: ${shadeRgb(pRgb, 0.5, true)};

      --color-secondary: ${secondary};
      --color-secondary-50: ${shadeRgb(sRgb, 0.95)};
      --color-secondary-100: ${shadeRgb(sRgb, 0.9)};
      --color-secondary-200: ${shadeRgb(sRgb, 0.8)};
      --color-secondary-300: ${shadeRgb(sRgb, 0.7)};
      --color-secondary-400: ${shadeRgb(sRgb, 0.6)};
      --color-secondary-500: ${sRgb.r}, ${sRgb.g}, ${sRgb.b};
      --color-secondary-600: ${shadeRgb(sRgb, 0.8, true)};
      --color-secondary-700: ${shadeRgb(sRgb, 0.7, true)};
      --color-secondary-800: ${shadeRgb(sRgb, 0.6, true)};
      --color-secondary-900: ${shadeRgb(sRgb, 0.5, true)};

      /* Dark-mode overrides; prefer backend dark values if available, otherwise fall back to the light settings */
      --color-background: ${bgDarkFromSettings};
      --color-surface: ${settings?.surface_dark || settings?.surface || '#1f2937'};
      --color-border: ${settings?.border_dark || settings?.border || '#374151'};
      --color-text: ${textDarkFromSettings};
     }
   }`;

  // Inline style on the <html> element to ensure the CSS variables take precedence
  // (style attribute has higher priority than stylesheet declarations and évite l'écrasement
  // par les règles @media (prefers-color-scheme: dark)).
  // Build a simple map of custom properties (strings) and cast it for the style prop.
  const htmlStyleMap: Record<string, string> = {
    '--color-background': String(bgFromSettings),
    '--color-text': String(textFromSettings),
    '--color-primary': String(primary),
    '--color-secondary': String(secondary),
  };

  const htmlStyle = htmlStyleMap as unknown as React.CSSProperties;

  return (
    <html lang="en" style={htmlStyle}>
    <head>
      <title>{String(metadata.title ?? 'Create Next App')}</title>
      {/* Injecter les variables CSS du backend au plus tôt */}
      <style dangerouslySetInnerHTML={{ __html: inlineCss }} />
    </head>
    {/* Ne pas appliquer les variables de font globalement ici pour préserver la police par défaut (Fjord One)
        Charger/assigner les fonts via des classes locales ou composants si nécessaire. */}
    <body className={`${fjordOne.variable} antialiased`}>
    <ThemeProvider>{children}</ThemeProvider>
    </body>
    </html>
  );
}
